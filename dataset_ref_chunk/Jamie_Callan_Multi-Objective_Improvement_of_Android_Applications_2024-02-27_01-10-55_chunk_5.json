{"file_path": "/Users/sz904/Desktop/11711/LTI_Neural_Navigator/data/2024-02-26/chunk_paper_txt/Jamie_Callan_Multi-Objective_Improvement_of_Android_Applications_2024-02-27_01-10-55_chunk_5.txt", "num_qa_pairs": 10, "qa_list": [{"question": " What is the challenge of applying Genetic Improvement (GI) to the mobile domain?", "answer": " The challenge is the accurate measurement of the fitness function, especially in apps that run in more than 150ms.", "ref_chunk": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}, {"question": " How is the program representation structured in the GI framework?", "answer": " The program representation consists of a list of edits that are applied sequentially to the source code.", "ref_chunk": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}, {"question": " How is the Fitness section in the GI framework used to measure improvement properties?", "answer": " In the Fitness section, the application is patched, compiled, and run through unit tests. If all unit tests pass, the patch is considered valid, and the property being improved is measured.", "ref_chunk": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}, {"question": " What is the purpose of using the Robolectric testing library in the GI framework?", "answer": " Robolectric allows for simulation-based testing of application components within a local JVM, which helps in testing any application component with fast local tests.", "ref_chunk": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}, {"question": " According to Khalid et al (2015), what are the most complained about non-functional properties of Android apps?", "answer": " The most complained about non-functional properties are execution time, memory usage, bandwidth, and energy usage.", "ref_chunk": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}, {"question": " Why is it mentioned that improvements found with unit tests in the Robolectric library translate to improvements on Android applications run on real devices?", "answer": " The statement is supported by the findings of Callan and Petke (2022a), who found that improvements demonstrated with Robolectric testing translated to actual improvements on real devices in all cases.", "ref_chunk": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}, {"question": " What is the primary technique for improving bandwidth in Android apps mentioned in the text?", "answer": " The primary technique mentioned is prefetching.", "ref_chunk": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}, {"question": " Why is utilizing multi-objective approaches in the search process considered important in the mobile domain?", "answer": " It is important due to limited resources and the ability to evolve patches that balance different trade-offs, producing Pareto fronts of solutions.", "ref_chunk": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}, {"question": " How is the initial population of patches generated in the search process?", "answer": " The initial population consists of individuals with single random edits, which are further guided by a search algorithm that applies mutations and crossovers.", "ref_chunk": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}, {"question": " What are the mechanisms used to create patches in the single-objective search used in GI?", "answer": " Patches are created through mutation and crossover on the list of edits representation.", "ref_chunk": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}], "doc_text": "of a program variant that deletes the statement with ID 608 and then copies the statement with ID 1307 to position 265 into the block with ID 365 in the file Example.java Another challenge of applying GI to the mobile domain is the accurate measure- ment of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that apps that run in more than 150ms are considered to be \u2018laggy\u2019 by users (Tolia et al (2006)). There- fore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour. In order to overcome the aforementioned challenges, we propose the GI framework shown in Figure 1. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved. 4.1 Representation We use a program representation consisting of a list of edits, which are applied sequen- tially to the source code. This representation has been used in GI many times in the past and proven successful Petke et al (2018). We use a list of edits, rather than rep- resenting the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Figure 2. 9 4.2 Fitness In the Fitness section in our framework (see Figure 1), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement. Due to the complexity of the Android build system and significant use of UI ele- ments, a minor change usually requires a time-costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw excep- tions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main fea- tures that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simu- lated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren\u2019t available in the Android operating system. Callan and Petke (2022a) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications. Khalid et al (2015) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps (Bokhari et al (2017); Morales et al (2018)) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption (Bokhari et al (2017)), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching (Mohan et al (2013)). No attempts have been made to improve it using source-code transformations, despite such changes being made by developers (Callan et al (2022)). We are the first to try to do so. 10 4.3 Search The Search section of our framework for Android app improvement (see Figure 1) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi- objective algorithms will allow us to evolve patches that will balance different trade- offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc. To start our search we need to generate an initial set of patches. Our patch repre- sentation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches. 4.3.1 Mutation and Crossover Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI"}
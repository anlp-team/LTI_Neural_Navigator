{"file_path": "/Users/sz904/Desktop/11711/LTI_Neural_Navigator/data/2024-02-26/chunk_paper_txt/Jamie_Callan_Multi-Objective_Improvement_of_Android_Applications_chunk_1.txt", "num_qa_pairs": 10, "qa_list": [{"question": " What are non-functional properties in mobile apps and why are they important?", "answer": " Non-functional properties in mobile apps, such as runtime or memory use, are important because they affect user experience.", "ref_chunk": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}, {"question": " What is the proposed tool for multi-objective automated improvement of Android apps mentioned in the text?", "answer": " The proposed tool is GIDroid.", "ref_chunk": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}, {"question": " What technique is used in GIDroid for navigating the space of software variants to find improved software?", "answer": " Genetic improvement is used as a search-based technique.", "ref_chunk": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}, {"question": " How does GIDroid greatly improve the speed of search in the simulation-based testing framework?", "answer": " GIDroid greatly improves the speed of search by using a simulation-based testing framework.", "ref_chunk": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}, {"question": " What percentage of existing improvements did GIDroid automatically rediscover when applied to versions of mobile apps?", "answer": " GIDroid automatically rediscovered 64% of existing improvements when applied to versions of mobile apps.", "ref_chunk": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}, {"question": " What was the maximum improvement in execution time achieved by applying the proposed approach to current versions of software?", "answer": " The maximum improvement in execution time achieved was up to 35%.", "ref_chunk": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}, {"question": " What was the maximum improvement in memory use achieved by applying the proposed approach to current versions of software?", "answer": " The maximum improvement in memory use achieved was up to 33%.", "ref_chunk": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}, {"question": " According to the text, what percentage of instances of users abandoning applications and bad reviews were due to poor performance in Android apps?", "answer": " 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance in Android apps.", "ref_chunk": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}, {"question": " What is the main entry point for Android applications, as mentioned in the text?", "answer": " The main entry point for Android applications is its UI components.", "ref_chunk": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}, {"question": " What approach does the text argue would make developers more likely to adopt for improving non-functional properties of Android apps?", "answer": " The text argues that an approach not requiring external resources and applicable to all applications would make developers more likely to adopt it.", "ref_chunk": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}], "doc_text": "3 2 0 2 g u A 2 2 ] E S . s c [ 1 v 7 8 3 1 1 . 8 0 3 2 : v i X r a Multi-Objective Improvement of Android Applications James, Callan1* and Justyna Petke1* 1*Computer Science Department, University College London, Gower Street, London, WC1E 6BT, Greater London, United Kingdom. Corresponding author(s). E-mail(s): james.callan.19@ucl.ac.uk; j.petke@ucl.ac.uk; Abstract Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. Previous work on automated improvement of non-functional properties in mobile apps failed to address the inherent trade-offs between such properties. We propose a practical approach and the first open-source tool, GIDroid (2023), for multi-objective automated improvement of Android apps. In particular, we use Genetic improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid contains three state- of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps. Keywords: Android apps, genetic improvement, multi-objective optimization, search-based software engineering 1 1 Introduction Android applications (or apps for short) are one of the most widely used types of software (Kemp (2022)). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non- functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance (Lim et al (2014); Inukollu et al (2014)). Hort et al (2022)\u2019s survey on Android performance optimizations lists sev- eral approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed (Mohan et al (2013); Baumann and Santini (2017)) and offloading compu- tation onto remote servers which are faster than the mobile device (Saarinen et al (2012)). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches (Hort et al (2022)) include anti-pattern detection, which requires manual implementation, and refactor- ings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it. Whilst existing approaches for automated improvement of Android apps are capa- ble of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered (Hort et al (2022)). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et al (2022) reveals only one work that applies multi-objective opti- mization to non-functional properties of Android apps. Morales et al (2018) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements. Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer (Lin et al (2014)) and AsyncDroid (Lin et al (2015)), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to exe- cute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et al (2018) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops. 2 The only tools for Android app performance improvement, which are both avail- able and generally applicable to Android source code, are linters (Habchi et al (2018)). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. How- ever, their use comes with challenges (Habchi et al (2018)), including dealing with false positives. In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including run- time (Langdon et al (2015); Petke et al (2013)), memory (Basios et al (2017); Wu et al (2015)), and energy consumption (Bruce et al (2015); Burles et al (2015)). Extending GI to improve multiple properties can be accomplished by swapping"}
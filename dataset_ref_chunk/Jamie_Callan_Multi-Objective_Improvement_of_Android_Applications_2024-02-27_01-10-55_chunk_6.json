{"file_path": "/Users/sz904/Desktop/11711/LTI_Neural_Navigator/data/2024-02-26/chunk_paper_txt/Jamie_Callan_Multi-Objective_Improvement_of_Android_Applications_2024-02-27_01-10-55_chunk_6.txt", "num_qa_pairs": 10, "qa_list": [{"question": " What is the purpose of the crossover technique mentioned in the text?,answer: The purpose of the crossover technique is to combine edits from patches selected using binary tournament selection.", "ref_chunk": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}, {"question": " How does a mutation operate in the context discussed in the text?,answer: A mutation in this context simply adds or deletes an edit, operating on the statement-level to delete, remove, or replace another statement.", "ref_chunk": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}, {"question": " According to the work of Callan et al (2022), what technique is suggested for improving non-functional properties of Android apps?,answer: Caching is suggested as one of the most common techniques for improving non-functional properties of Android apps.", "ref_chunk": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}, {"question": " What is the potential benefit of using caching in Android apps?,answer: Caching can help improve runtime by saving time, reduce memory footprint, and decrease network usage by avoiding unnecessary operations.", "ref_chunk": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}, {"question": " What are the two new mutation operators proposed based on the manual analysis of the commits mentioned in the text?,answer: The two new mutation operators proposed are the In-Method Caching Operator and the Class Caching Operator.", "ref_chunk": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}, {"question": " What is the purpose of the In-Method Caching Operator?,answer: The purpose of the In-Method Caching Operator is to store the result of a method call in a local variable and replace future calls to this method with the local variable.", "ref_chunk": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}, {"question": " How does the Class Caching Operator differ from the In-Method Caching Operator?,answer: The Class Caching Operator creates new fields in the associated class for storing cached method calls, allowing the cached variables to persist beyond individual method calls.", "ref_chunk": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}, {"question": " What is the research question RQ1 mentioned in the text?,answer: RQ1: Can MO-GI optimize Android apps in the same way as real developers?", "ref_chunk": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}, {"question": " What is the significance of answering the research question RQ2 in the context of the text?,answer: Answering RQ2 will help determine how well the MO-GI approach generalizes in finding improvements in current code without known optimizations.", "ref_chunk": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}, {"question": " Why is investigating the most effective MO algorithm important according to the text?,answer: Investigating the most effective MO algorithm is crucial to ensure that the approach utilizes the best algorithm for optimizing Android apps effectively.", "ref_chunk": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}], "doc_text": "so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, remove, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain. Callan et al (2022).\u2019s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied and improved a number of different appli- cations in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.\u2019s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory foot- print of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search. First, we propose a simple In-Method Caching Operator. This operator sim- ply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm 1). An example of this operator 11 Algorithm 1 Find method calls to cache in Method M 1: function MethodCacheFinder(C) 2: seen = \u2205 cachable = \u2205 for each expression e in M do 3: 4: 5: if e is a method call expression then 6: if e \u2208 seen then 7: cachable = cachable \u222a e 8: else 9: seen = seen \u222a e 10: end if 11: end if end for Return cachable 12: 13: 14: end function Original Code Mutated Code i n t x = f o o ( a , b , c ) ; i n t y = f o o ( a , b , c ) ; int cachedVar1 = foo(a,b,c); i n t x = cachedVar1 ; i n t y = cachedVar1 ; Fig. 3 An example of the In-Method Cache Operator. The resultant code stores the results of a method call f oo, with parameters a, b and c. This stored result can then be used later in the same method. can be seen in Figure 3. The second caching operator creates new fields in the asso- ciated class for storing cached method calls. This Class Caching Operator allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Figure 4. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same vari- able only if their arguments consist of the same variables. As shown in Algorithm 2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method\u2019s return type. 5 Research Questions To evaluate how effective the multi-objective GI approach for improvement of Android apps\u2019 runtime, memory, and bandwidth use is, we pose the following research questions: 12 Algorithm 2 Find method calls to cache in Class C 1: function ClassCacheFinder(M ) 2: cachable = \u2205 for each method m in C do 3: 4: for each expression e in m do 5: if e is a method call expression then 6: cachable = cachable \u222a e 7: end if 8: end for end for Return cachable 9: 10: 11: end function Original Code Mutated Code c l a s s C1 { p u b l i c v o i d f o o ( ) { i n t x = a ( ) ; } c l a s s C1 { int cachedVar1; p u b l i c v o i d f o o ( ) { if (cachedVar1 == null){ } cachedVar1 = a(); } i n t x = cachedVar1; } } Fig. 4 An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method. RQ1: Can MO-GI optimize Android apps in the same way as real developers? In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past. RQ2: How effective is MO-GI at optimising Android apps without known improvements? Answering this question will allow us to see how well our approach generalises. In particular, if it\u2019s able to find improvements in current code. RQ3: Which MO algorithm is the most effective for MO-GI for Android? There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past. RQ4:"}
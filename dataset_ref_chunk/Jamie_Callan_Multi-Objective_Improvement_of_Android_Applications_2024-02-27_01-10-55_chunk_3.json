{"file_path": "/Users/sz904/Desktop/11711/LTI_Neural_Navigator/data/2024-02-26/chunk_paper_txt/Jamie_Callan_Multi-Objective_Improvement_of_Android_Applications_2024-02-27_01-10-55_chunk_3.txt", "num_qa_pairs": 10, "qa_list": [{"question": " What are some tools used in Android development to identify areas of code that may cause performance issues?", "answer": " Some tools used in Android development to identify performance issues include linters like PMD and FindBugs.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " Why are warnings from Android linters often considered false-positives?", "answer": " Warnings from Android linters are often considered false-positives because developers must manually verify and fix the detected issues.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " What do refactoring approaches aim to achieve in terms of code performance?", "answer": " Refactoring approaches aim to modify the source code of the application to be more performant, such as by executing code asynchronously.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " What is the benefit of offloading computation to external servers in Android apps?", "answer": " Offloading computation to external servers can reduce energy usage, extend battery life, and make the app more responsive by speeding up computation.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " Which programming languages are commonly used in Android app development?", "answer": " Commonly used programming languages in Android app development include Java, Kotlin, and C/C++ for native code.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " What is the purpose of Genetic Improvement (GI) in software engineering?", "answer": " Genetic Improvement (GI) is a search-based software engineering technique used to find improved program variants by iterating over different versions of software.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " How are GI patches constructed in the context of software improvement?", "answer": " GI patches are constructed from a set of edits to code, known as mutations, which describe modifications to the program being improved.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " What is the role of fitness function in evaluating GI patches?", "answer": " The fitness function is used to measure the effectiveness of GI patches in terms of desired outcomes such as passing tests or execution time improvement.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " How does Genetic Improvement (GI) differ from traditional software improvement techniques?", "answer": " Genetic Improvement (GI) differs from traditional software improvement techniques by using search-based optimization to find improved program variants through iterative changes.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " Why is GI considered fully automated in the context of software optimization?", "answer": " GI is considered fully automated because developers only need to review the patches produced by GI once the process is finished, ensuring no unintended side effects.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}], "doc_text": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}
{"file_path": "/Users/sz904/Desktop/11711/LTI_Neural_Navigator/data/2024-02-26/chunk_paper_txt/Graham_Neubig_Learning_Performance-Improving_Code_Edits_chunk_8.txt", "num_qa_pairs": 10, "qa_list": [{"question": " What is the Miscellaneous category and how much of the changes does it encompass?", "answer": " The Miscellaneous category encompasses approximately 18.70% of changes.", "ref_chunk": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}, {"question": " What are some examples of optimizations included in the Miscellaneous category?", "answer": " Examples include code cleanups, omitting unnecessary initializations, and replacing computationally intensive functions with predefined constants.", "ref_chunk": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}, {"question": " In the program for determining the range between the maximum and minimum values from a set of input pairs, how does the faster code optimize the process?", "answer": " The faster code directly computes the maximum start and minimum end of the ranges in a single pass, eliminating the need for sorting.", "ref_chunk": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}, {"question": " What is the purpose of the code implementations in Figure 5?", "answer": " The code implementations are for computing factorial modulo 10^9+7.", "ref_chunk": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}, {"question": " How does the optimized code in Figure 5 differ from the slower code?", "answer": " The optimized code computes the factorial only for the given input, making it more memory-efficient and faster.", "ref_chunk": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}, {"question": " What is the complexity of the slower code in Figure 6 for modular arithmetic?", "answer": " The slower code has a complexity of O(10^6).", "ref_chunk": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}, {"question": " What does the optimized code in Figure 6 leverage to reduce complexity?", "answer": " The optimized code leverages the property of modular arithmetic to reduce the complexity to O(B).", "ref_chunk": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}, {"question": " How does the optimized code in Figure 7 improve upon the slower code?", "answer": " The optimized code avoids an additional conditional check inside the loop by restructuring the loop.", "ref_chunk": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}, {"question": " What is the purpose of the example in A.4 about multiple submissions and measured runtimes?", "answer": " The purpose is to highlight the speedup reported despite identical programs and environments due to template code.", "ref_chunk": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}, {"question": " What generation parameters are used for prompting GPT-3.5 in self-play data generation described in A.4?", "answer": " A temperature of 1.0 and use of top-p sampling with p = 0.9 are used for generation.", "ref_chunk": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}], "doc_text": "from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate. Miscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants. int main(){ int main(){ int n, m, a, b; vector<int> v, v1; cin >> n >> m; for(int i = 0; i < m; i++){ int n, m, a, b, max = -1, min = 1e9; scanf(\"%d%d\", &n, &m); for(int i = 0; i < m; i++){ scanf(\"%d%d\", &a, &b); if(a > max) max = a; if(b < min) min = b; } cin >> a >> b; v.push_back(a); v1.push_back(b); } ans = min - max + 1; if(ans < 0){ ans = 0; sort(v.begin(), v.end()); sort(v1.begin(), v1.end()); } printf(\"%d\\n\", ans); return 0; if(v.back() > v1[0]){ cout << 0 << endl; } } else { cout << v1[0] - v.back() + 1 << endl; (b) Faster Code. } } return 0; (a) Slower Code. Figure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass (O(n)), eliminating the need for sorting (O(n log n)). 15 Preprint. Under review. int main(){ int k,x; cin>>k>>x; for (int i=-1000000;i<1000001;i++) { if(i==x){ int main(){ int k,x; scanf(\"%d %d\",&k,&x); for(int i=x-k+1;i<=x+k-1;i++) printf(\"%d \",i); for (i=x-(k-1);i<x+k;i++){ cout<< i<<\" \"; } return 0; } } } return 0; (b) Faster Code. } (a) Slower Code. Figure 4: Comparison of two code implementations for printing 2k \u2212 1 consecutive numbers centered around the input x. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations. int main() { int i, n; long long num[100005] = {0,1}; for (i = 2; i <= 100004; i++) num[i] = (num[i-1] * i)%(1000000007); scanf(\"%d\", &n); printf(\"%lld\\n\", num[n]); return 0; } long long a=1,mod=1e9+7; int n; int main() { scanf(\"%d\",&n); for(int i=1;i<=n;i++) { a=(a*i)%mod; } printf(\"%lld\",a); } (a) Slower Code. (b) Faster Code. Figure 5: Comparison of two code implementations for computing factorial modulo 109+7. The slower code (left) precomputes the factorial for all numbers up to 105, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version. A.2 PIE DATASET DETAILS Dataset Unique Problem IDs Train Val Test 1,474 77 41 Table 4: Number of unique problem ids. 16 Preprint. Under review. int main() { int main() { int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); int A, B, C; scanf(\"%d %d %d\", &A, &B, &C); bool isYes = false; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if ((A * i) - (B * j) == C) bool is_yes = false; for (int i = 0; i < B; i++) { if ((A * i) % B == C) is_yes = true; isYes = true; } } } printf(\"%s\\n\", is_yes ? \"YES\" : \"NO\"); return 0; printf(\"%s\\n\", isYes ? \"YES\" : \"NO\"); return 0; } } (b) Optimized Code. (a) Slower Code with Nested Loops. Figure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of i and j leading to a complexity of O(106). The faster code leverages the property of modular arithmetic, reducing the complexity to O(B). By directly computing the modulo operation for each i in the range [0, B \u2212 1], it efficiently determines if the condition (A \u00d7 i) mod B = C is satisfied. int main() { int i,n,m; cin>>n>>m; for(i=m-n+1;i<m+n;i++){ int main(){ int n,m; scanf(\"%d%d\",&n,&m); for(int i=m-n+1;i<m;i++){ printf(\"%d \",i); } cout<<i; if(i!=m+n-1) cout<<\" \"; } printf(\"%d\",m); for(int i=m+1;i<m+n;i++){ printf(\" %d\",i); } (a) Slower Code. } } printf(\"\\n\"); return 0; (b) Optimized Code. Figure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop. A.3 EXAMPLE OF DUPLICATE CODE IN CODENET WITH DIFFERENT MEASURED RUNTIMES Here is one example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of 2.44\u00d7 is reported, despite the programs and environments being identical. We note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments. A.4 SELF-PLAY DATA GENERATION DETAILS We use the template in Figure 9 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with p = 0.9 For each prompt, we try attempt to take n = 5 samples. We chose these samples after doing a sweep of 6 configurations of 17 Preprint. Under review. Dataset Pairs Train Val Test 77,967 2,544 982 Table 5: Number of pairs. Dataset Mean src Mean tgt Median src Median tgt Train Val Test 675.00 644.74 429.12 616.44 471.47 398.78 417 180 363 372 110 318.5 Table 6: GPT-2 Tokenizer lengths. generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively"}
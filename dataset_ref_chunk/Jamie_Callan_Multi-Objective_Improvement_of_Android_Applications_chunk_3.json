{"file_path": "/Users/sz904/Desktop/11711/LTI_Neural_Navigator/data/2024-02-26/chunk_paper_txt/Jamie_Callan_Multi-Objective_Improvement_of_Android_Applications_chunk_3.txt", "num_qa_pairs": 10, "qa_list": [{"question": " What are some examples of Android linters mentioned in the text?", "answer": " Some examples of Android linters mentioned in the text are PMD, FindBugs, and Lin (Android Development Team (2023b)).", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " What is a common issue mentioned regarding warnings from Android linters?", "answer": " A common issue mentioned regarding warnings from Android linters is that they often produce false-positives.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " What is the main goal of refactoring approaches in the context of Android app development?", "answer": " The main goal of refactoring approaches in the context of Android app development is to modify the source code to improve performance.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " According to the text, what is one proposed refactoring approach by Lyu et al (2018)?", "answer": " One proposed refactoring approach by Lyu et al (2018) is to move database operations out of loops.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " What is the benefit of the offloading approach in Android app development?", "answer": " The benefit of the offloading approach in Android app development is reducing energy usage, extending battery life, and speeding up computation.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " What are two common programming languages used for Android app development mentioned in the text?", "answer": " Two common programming languages used for Android app development mentioned in the text are Java and Kotlin.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " What is Genetic Improvement (GI) according to the text?", "answer": " Genetic Improvement (GI) is a search-based software engineering technique that iterates over different versions of software to find improved program variants.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " How are GI patches represented in the text?", "answer": " GI patches are represented as patches to existing software constructed from mutations like delete, copy, and replace operations.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " What is the purpose of using fitness functions in GI according to the text?", "answer": " The purpose of using fitness functions in GI is to guide search through patches to find improved software variants based on criteria like passing tests or execution time.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}, {"question": " How does GI differ from traditional software improvement methods mentioned in the text?", "answer": " GI does not require external infrastructure, can be performed locally, and is fully automated, unlike some traditional software improvement methods mentioned in the text.", "ref_chunk": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}], "doc_text": "of Android apps are linters (Android Development Team (2023b)), PMD (Pmd Development Team (2023)), and FindBugs (FindBugs Development Team (2015)). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives (Habchi et al (2018)). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect. Refactoring: Refactoring approaches aim to modify the source code of the appli- cation to be more performant. In Lin et al (2014, 2015)\u2019s work applications were refactored to execute code asynchronously, making them execute more quickly. These approaches require developers to identify each line of code that they wish to execute asynchronously and there is no indication of the actual impact on performance of these changes. Lyu et al (2018) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls. Offloading: This approach aims to perform the most costly computation on exter- nal servers, rather than Android devices (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). This has the benefit of reducing the amount of energy used by the application, extending the device\u2019s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable. Programming Languages: In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance differ- ence between the two languages (Mateus et al (2021)). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains. 5 Table 1 Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool \u2013 GIDroid. Work Properties Source Trade-offs Code Automatic Considered Fully Runtime Prefetching Runtime, Memory Anti-Patterns Refactoring - Asynchronous Runtime Refactoring - Database Loops Runtime Offloading GIDroid Runtime, Energy Use Runtime, Memory, Bandwidth x \u2713 \u2713 \u2713 x \u2713 \u2713 x x \u2713 \u2713 \u2713 x x x x x \u2713 The above works have all proved useful, but they either do not perform fully automatic improvement (Lin et al (2014, 2015); Habchi et al (2018); FindBugs Devel- opment Team (2015); Android Development Team (2023b)), are only applicable to specific areas of code (Lyu et al (2018); Mohan et al (2013); Baumann and Santini (2017)), or require external infrastructure (Das et al (2016); Chun et al (2011); Ding et al (2013); Berg et al (2014); Saarinen et al (2012)). Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table 1. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI. 3 Background Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization. 3.1 Genetic Improvement Genetic Improvement (GI) (Petke et al (2018)) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improve- ments to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the devel- opment of commercial software (Haraldsson et al (2017)), improving the execution 6 time of large bioinformatics software (Langdon et al (2015)), improving compiler optimizations (Li et al (2022)), and more (Petke et al (2018)). Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previ- ous work have been: delete, copy, and replace. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree (AST). Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search,"}
{
    "file_path": "/home/ubuntu/LTI_Neural_Navigator/data/2024-02-26/html/Edmund_Clarke_-_A.M._Turing_Award_Laureate.txt",
    "num_qa_pairs": 53,
    "doc_text": "A.M. TURING CENTENARY CELEBRATION WEBCAST\n\nMORE ACM AWARDS\n\nHOME\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA.M. TURING AWARD LAUREATES BY...\n\nALPHABETICAL LISTING\n\nYEAR OF THE AWARD\n\nRESEARCH SUBJECT\n\nPHOTOGRAPHS\n\nBIRTH:\n\nJuly 27, 1945.\n\nDEATH:\n\nDecember 22, 2020.\n\nEDUCATION:\n\nBA, Mathematics, (University of Virginia, 1967); MA Mathematics (Duke University, 1968);Ph.D., Computer Science (Cornell University, 1976)\n\nEXPERIENCE:\n\nDuke University (1976\u20131978); Harvard University (1978\u20131982); Carnegie Mellon University (1982\u2013present, including FORE Systems Professor 1995\u2013present, University Professor 2008\u2013present).\n\nHONORS AND AWARDS:\n\nTechnical Excellence Award, Semiconductor Research Corporation (1995); ACM Paris Kanellakis Theory and Practice Award (1998, with Randal Bryant, E. Allen Emerson, and Kenneth L. McMillan); IEEE Harry H. Goode Memorial Award (2004); Elected to National Academy of Engineering (2005); ACM Turing award (2007, with Emerson and Sifakis); International Conference on Automated Deduction (CADE) Herbrand Award for Distinguished Contributions to Automated Reasoning (2008); Logic in Computing Science (LICS) 2010 Test-of-Time Award for his 1990 paper, \"Symbolic model checking\u2026; Elected to the American Academy of Arts and Sciences (2011); Fellow of the ACM and IEEE; Honorary Doctorate, (Vienna University of Technology, 2012); Bower Award and Prize for Achievement in Science from the Franklin Institute (2014) .\n\nEdmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education\n\nEdmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard University in 1978. He joined Carnegie Mellon University in 1982, where he is currently the FORE Systems University Professor of Computer Science and Professor of Electrical and Computer Engineering.\n\nClarke\u2019s career has focused on mathematical reasoning about computer systems, with an emphasis on reasoning about the reliability of those systems. Such reasoning is necessary but very hard. A computer system executes simple operations, but those operations can occur in a staggering number of different orders. This makes it impossible for the designer to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.\n\nThe sequences become even more difficult to envision in systems with multiple programs running at the same time\u2014a feature that has long been present in computer hardware and has become widespread in software since the beginning of the 21st century. Mathematical reasoning, and specifically its expression in formal logic, in principle is sufficient to describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical mathematical reasoning is awkwardly-matched to describing the many possible execution orderings in a computer system.\n\nInventing model checking\n\nEarly researchers addressed this mismatch by developing logical forms better-suited to describing computer systems. One of the first was by Tony Hoare . Hoare\u2019s logic could be used to prove that every possible execution of a system would only execute an acceptable sequence of operations. This opened the possibility that systems could be proven to perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and extended his method. Although Hoare\u2019s method worked for smaller systems, it was close to impossible to apply to systems of any real size. The dream of powerful, effective methods for reasoning about all possible orderings of a system remained unfulfilled.\n\nIn 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.\n\nClarke and his student E. Allen Emerson saw an important possibility in temporal logic: it could be directly checked by machine. Whereas Hoare\u2019s logic required the designer to consider every detail of both the system and the argument about the system\u2019s correctness\u2014substantially increasing the designer\u2019s workload\u2014Pnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.\n\nClarke and Emerson realized that a program could exhaustively construct every possible sequence of actions a system might perform, and for every action it could evaluate a property expressed in temporal logic. If the program found the property to be true for every possible action in every possible sequence, this proved the property for the system. In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified property. Working independently, Jean-Pierre Queille and Joseph Sifakis developed similar ideas. The technology of model checking was born.\n\nA great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion\n\nAlthough the 1981 paper [ 2 ] demonstrated that the model checking was possible in principle, its application to practical systems was severely limited. The most pressing limitation was the number of states to search. Early model checkers required explicitly computing every possible configuration of values the program might assume. For example, if a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.\n\nSystems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.\n\nClarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.\n\nThe new representation dramatically reduced the storage required to represent state spaces, in turn reducing the time required to run a model checker on systems of practical size. They called these new systems symbolic model checkers. In 1995, Clarke, McMillan, and colleagues used this approach to demonstrate flaws in the design of an IEEE standard for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked.\n\nWith enhancements such as these, model checking has become a mature technology. It is widely used to verify designs for integrated circuits, computer networks, and software, by companies such as Intel and Microsoft. Model checkers have been used to analyze systems whose state space (10 120) is substantially larger than the number of atoms in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of integrated circuits, which feature multiple processors running simultaneously. Model checking has substantially improved the reliability and safety of the systems upon which modern life depends.\n\nAuthor: Ted Kirkpatrick\n\nABOUT THE A.M. TURING AWARD NOMINATIONS\n\nVIDEO: THE ORIGINS OF THE AWARD\n\n2021 LAUREATE: JACK DONGARRA\n\nTHE A.M. TURING AWARD LECTURES\n\nACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals, delivering a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society.\n\n\u00a9 2019 Association for Computing Machinery. All rights reserved.",
    "qa_list": [
        {
            "question": "When was Edmund Melson Clarke born?",
            "answer": "Edmund Melson Clarke was born on July 27, 1945.",
            "top_k_docs": {
                "0": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard",
                "1": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education",
                "2": "EXPERIENCE:\n\nDuke University (1976\u20131978); Harvard University (1978\u20131982); Carnegie Mellon University (1982\u2013present, including FORE Systems Professor 1995\u2013present, University Professor 2008\u2013present).\n\nHONORS AND AWARDS:",
                "3": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "4": "Author: Ted Kirkpatrick\n\nABOUT THE A.M. TURING AWARD NOMINATIONS\n\nVIDEO: THE ORIGINS OF THE AWARD\n\n2021 LAUREATE: JACK DONGARRA\n\nTHE A.M. TURING AWARD LECTURES\n\nACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals, delivering a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society.\n\n\u00a9 2019 Association for Computing Machinery. All rights reserved."
            },
            "qa_cat": "When was Edmund Melson Clarke born?\nEdmund Melson Clarke was born on July 27, 1945."
        },
        {
            "question": "What degree did Edmund Melson Clarke receive from the University of Virginia in 1967?",
            "answer": "He received a BA from the University of Virginia in 1967.",
            "top_k_docs": {
                "0": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard",
                "1": "A.M. TURING CENTENARY CELEBRATION WEBCAST\n\nMORE ACM AWARDS\n\nHOME\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA.M. TURING AWARD LAUREATES BY...\n\nALPHABETICAL LISTING\n\nYEAR OF THE AWARD\n\nRESEARCH SUBJECT\n\nPHOTOGRAPHS\n\nBIRTH:\n\nJuly 27, 1945.\n\nDEATH:\n\nDecember 22, 2020.\n\nEDUCATION:\n\nBA, Mathematics, (University of Virginia, 1967); MA Mathematics (Duke University, 1968);Ph.D., Computer Science (Cornell University, 1976)\n\nEXPERIENCE:",
                "2": "EXPERIENCE:\n\nDuke University (1976\u20131978); Harvard University (1978\u20131982); Carnegie Mellon University (1982\u2013present, including FORE Systems Professor 1995\u2013present, University Professor 2008\u2013present).\n\nHONORS AND AWARDS:",
                "3": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "4": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked."
            },
            "qa_cat": "What degree did Edmund Melson Clarke receive from the University of Virginia in 1967?\nHe received a BA from the University of Virginia in 1967."
        },
        {
            "question": "Where did Edmund Melson Clarke study under Robert Constable?",
            "answer": "Edmund Melson Clarke studied under Robert Constable at Cornell University.",
            "top_k_docs": {
                "0": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard",
                "1": "EXPERIENCE:\n\nDuke University (1976\u20131978); Harvard University (1978\u20131982); Carnegie Mellon University (1982\u2013present, including FORE Systems Professor 1995\u2013present, University Professor 2008\u2013present).\n\nHONORS AND AWARDS:",
                "2": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "3": "Author: Ted Kirkpatrick\n\nABOUT THE A.M. TURING AWARD NOMINATIONS\n\nVIDEO: THE ORIGINS OF THE AWARD\n\n2021 LAUREATE: JACK DONGARRA\n\nTHE A.M. TURING AWARD LECTURES\n\nACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals, delivering a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society.\n\n\u00a9 2019 Association for Computing Machinery. All rights reserved.",
                "4": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked."
            },
            "qa_cat": "Where did Edmund Melson Clarke study under Robert Constable?\nEdmund Melson Clarke studied under Robert Constable at Cornell University."
        },
        {
            "question": "What is the name of the university where Edmund Melson Clarke currently works?",
            "answer": "Clarke currently works at Carnegie Mellon University, where he is the FORE Systems University Professor of Computer Science and Professor of Electrical and Computer Engineering.",
            "top_k_docs": {
                "0": "making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard University in 1978. He joined Carnegie Mellon University in 1982, where he is currently the FORE Systems University Professor of Computer Science and Professor of Electrical and Computer Engineering.",
                "1": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard",
                "2": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education",
                "3": "Author: Ted Kirkpatrick\n\nABOUT THE A.M. TURING AWARD NOMINATIONS\n\nVIDEO: THE ORIGINS OF THE AWARD\n\n2021 LAUREATE: JACK DONGARRA\n\nTHE A.M. TURING AWARD LECTURES\n\nACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals, delivering a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society.\n\n\u00a9 2019 Association for Computing Machinery. All rights reserved.",
                "4": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly."
            },
            "qa_cat": "What is the name of the university where Edmund Melson Clarke currently works?\nClarke currently works at Carnegie Mellon University, where he is the FORE Systems University Professor of Computer Science and Professor of Electrical and Computer Engineering."
        },
        {
            "question": "What has been Edmund Melson Clarke's career focus?",
            "answer": "Clarke\u2019s career has focused on mathematical reasoning about computer systems, with an emphasis on reasoning about the reliability of those systems.",
            "top_k_docs": {
                "0": "Clarke\u2019s career has focused on mathematical reasoning about computer systems, with an emphasis on reasoning about the reliability of those systems. Such reasoning is necessary but very hard. A computer system executes simple operations, but those operations can occur in a staggering number of different orders. This makes it impossible for the designer to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be",
                "1": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard",
                "2": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education",
                "3": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.",
                "4": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked."
            },
            "qa_cat": "What has been Edmund Melson Clarke's career focus?\nClarke\u2019s career has focused on mathematical reasoning about computer systems, with an emphasis on reasoning about the reliability of those systems."
        },
        {
            "question": "Why is it necessary to reason mathematically about computer systems?",
            "answer": "It is necessary but very hard because a computer system executes simple operations that can occur in a staggering number of different orders. This makes it impossible for the designer to envision every possible sequence and predict its consequences.",
            "top_k_docs": {
                "0": "Clarke\u2019s career has focused on mathematical reasoning about computer systems, with an emphasis on reasoning about the reliability of those systems. Such reasoning is necessary but very hard. A computer system executes simple operations, but those operations can occur in a staggering number of different orders. This makes it impossible for the designer to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be",
                "1": "The sequences become even more difficult to envision in systems with multiple programs running at the same time\u2014a feature that has long been present in computer hardware and has become widespread in software since the beginning of the 21st century. Mathematical reasoning, and specifically its expression in formal logic, in principle is sufficient to describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical",
                "2": "Systems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.",
                "3": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.",
                "4": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states."
            },
            "qa_cat": "Why is it necessary to reason mathematically about computer systems?\nIt is necessary but very hard because a computer system executes simple operations that can occur in a staggering number of different orders. This makes it impossible for the designer to envision every possible sequence and predict its consequences."
        },
        {
            "question": "What could be the worst consequence if a program executes an incorrect sequence?",
            "answer": "The worst consequence if a program executes an incorrect sequence is that it could cause injury or loss of life.",
            "top_k_docs": {
                "0": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "1": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "2": "Early researchers addressed this mismatch by developing logical forms better-suited to describing computer systems. One of the first was by Tony Hoare . Hoare\u2019s logic could be used to prove that every possible execution of a system would only execute an acceptable sequence of operations. This opened the possibility that systems could be proven to perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and",
                "3": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "4": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education"
            },
            "qa_cat": "What could be the worst consequence if a program executes an incorrect sequence?\nThe worst consequence if a program executes an incorrect sequence is that it could cause injury or loss of life."
        },
        {
            "question": "Why does every one of those sequences, no matter how infrequently executed, must be correct?",
            "answer": "Every one of those sequences, no matter how infrequently executed, must be correct because if a program executes an incorrect sequence at the very least it will waste a user\u2019s time.",
            "top_k_docs": {
                "0": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "1": "The sequences become even more difficult to envision in systems with multiple programs running at the same time\u2014a feature that has long been present in computer hardware and has become widespread in software since the beginning of the 21st century. Mathematical reasoning, and specifically its expression in formal logic, in principle is sufficient to describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical",
                "2": "Early researchers addressed this mismatch by developing logical forms better-suited to describing computer systems. One of the first was by Tony Hoare . Hoare\u2019s logic could be used to prove that every possible execution of a system would only execute an acceptable sequence of operations. This opened the possibility that systems could be proven to perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and",
                "3": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked.",
                "4": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states."
            },
            "qa_cat": "Why does every one of those sequences, no matter how infrequently executed, must be correct?\nEvery one of those sequences, no matter how infrequently executed, must be correct because if a program executes an incorrect sequence at the very least it will waste a user\u2019s time."
        },
        {
            "question": "What degree did Edmund Melson Clarke receive from Duke University in 1968?",
            "answer": "He received an MA from Duke University in 1968.",
            "top_k_docs": {
                "0": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard",
                "1": "EXPERIENCE:\n\nDuke University (1976\u20131978); Harvard University (1978\u20131982); Carnegie Mellon University (1982\u2013present, including FORE Systems Professor 1995\u2013present, University Professor 2008\u2013present).\n\nHONORS AND AWARDS:",
                "2": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "3": "Author: Ted Kirkpatrick\n\nABOUT THE A.M. TURING AWARD NOMINATIONS\n\nVIDEO: THE ORIGINS OF THE AWARD\n\n2021 LAUREATE: JACK DONGARRA\n\nTHE A.M. TURING AWARD LECTURES\n\nACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals, delivering a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society.\n\n\u00a9 2019 Association for Computing Machinery. All rights reserved.",
                "4": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked."
            },
            "qa_cat": "What degree did Edmund Melson Clarke receive from Duke University in 1968?\nHe received an MA from Duke University in 1968."
        },
        {
            "question": "What are the challenges in describing sequences of operations in computer systems?",
            "answer": "Describing sequences of operations in computer systems can be difficult due to multiple programs running simultaneously and the many possible execution orderings.",
            "top_k_docs": {
                "0": "describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical mathematical reasoning is awkwardly-matched to describing the many possible execution orderings in a computer system.",
                "1": "Early researchers addressed this mismatch by developing logical forms better-suited to describing computer systems. One of the first was by Tony Hoare . Hoare\u2019s logic could be used to prove that every possible execution of a system would only execute an acceptable sequence of operations. This opened the possibility that systems could be proven to perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and",
                "2": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.",
                "3": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "4": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion"
            },
            "qa_cat": "What are the challenges in describing sequences of operations in computer systems?\nDescribing sequences of operations in computer systems can be difficult due to multiple programs running simultaneously and the many possible execution orderings."
        },
        {
            "question": "Who developed Hoare's logic for verifying system performance?",
            "answer": "Tony Hoare was one of the first researchers who developed logical forms better-suited to describing computer systems, including Hoare\u2019s logic that could prove every possible execution would only execute an acceptable sequence of operations.",
            "top_k_docs": {
                "0": "Early researchers addressed this mismatch by developing logical forms better-suited to describing computer systems. One of the first was by Tony Hoare . Hoare\u2019s logic could be used to prove that every possible execution of a system would only execute an acceptable sequence of operations. This opened the possibility that systems could be proven to perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and",
                "1": "Clarke and his student E. Allen Emerson saw an important possibility in temporal logic: it could be directly checked by machine. Whereas Hoare\u2019s logic required the designer to consider every detail of both the system and the argument about the system\u2019s correctness\u2014substantially increasing the designer\u2019s workload\u2014Pnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the",
                "2": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "3": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education",
                "4": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly."
            },
            "qa_cat": "Who developed Hoare's logic for verifying system performance?\nTony Hoare was one of the first researchers who developed logical forms better-suited to describing computer systems, including Hoare\u2019s logic that could prove every possible execution would only execute an acceptable sequence of operations."
        },
        {
            "question": "What did Clarke's early research do for Hoare's method?",
            "answer": "Clarke's early research strengthened the foundations of Hoare\u2019s logic and extended his method, making it applicable to smaller systems.",
            "top_k_docs": {
                "0": "perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and extended his method. Although Hoare\u2019s method worked for smaller systems, it was close to impossible to apply to systems of any real size. The dream of powerful, effective methods for reasoning about all possible orderings of a system remained unfulfilled.",
                "1": "Clarke and his student E. Allen Emerson saw an important possibility in temporal logic: it could be directly checked by machine. Whereas Hoare\u2019s logic required the designer to consider every detail of both the system and the argument about the system\u2019s correctness\u2014substantially increasing the designer\u2019s workload\u2014Pnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the",
                "2": "making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard University in 1978. He joined Carnegie Mellon University in 1982, where he is currently the FORE Systems University Professor of Computer Science and Professor of Electrical and Computer Engineering.",
                "3": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "4": "In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified property. Working independently, Jean-Pierre Queille and Joseph Sifakis developed similar ideas. The technology of model checking was born."
            },
            "qa_cat": "What did Clarke's early research do for Hoare's method?\nClarke's early research strengthened the foundations of Hoare\u2019s logic and extended his method, making it applicable to smaller systems."
        },
        {
            "question": "Why was Hoare's method difficult to apply to larger computer systems?",
            "answer": "Hoare's method for verifying system performance worked well for smaller systems but became close to impossible to apply to larger, more complex ones due to the sheer number of possible execution orderings.",
            "top_k_docs": {
                "0": "perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and extended his method. Although Hoare\u2019s method worked for smaller systems, it was close to impossible to apply to systems of any real size. The dream of powerful, effective methods for reasoning about all possible orderings of a system remained unfulfilled.",
                "1": "describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical mathematical reasoning is awkwardly-matched to describing the many possible execution orderings in a computer system.",
                "2": "Although the 1981 paper [ 2 ] demonstrated that the model checking was possible in principle, its application to practical systems was severely limited. The most pressing limitation was the number of states to search. Early model checkers required explicitly computing every possible configuration of values the program might assume. For example, if a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be",
                "3": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "4": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly."
            },
            "qa_cat": "Why was Hoare's method difficult to apply to larger computer systems?\nHoare's method for verifying system performance worked well for smaller systems but became close to impossible to apply to larger, more complex ones due to the sheer number of possible execution orderings."
        },
        {
            "question": "What did Amir Pnueli introduce in 1977?",
            "answer": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems that allows explicit reasoning about time.",
            "top_k_docs": {
                "0": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "1": "Clarke and his student E. Allen Emerson saw an important possibility in temporal logic: it could be directly checked by machine. Whereas Hoare\u2019s logic required the designer to consider every detail of both the system and the argument about the system\u2019s correctness\u2014substantially increasing the designer\u2019s workload\u2014Pnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the",
                "2": "Conference on Automated Deduction (CADE) Herbrand Award for Distinguished Contributions to Automated Reasoning (2008); Logic in Computing Science (LICS) 2010 Test-of-Time Award for his 1990 paper, \"Symbolic model checking\u2026; Elected to the American Academy of Arts and Sciences (2011); Fellow of the ACM and IEEE; Honorary Doctorate, (Vienna University of Technology, 2012); Bower Award and Prize for Achievement in Science from the Franklin Institute (2014) .",
                "3": "A.M. TURING CENTENARY CELEBRATION WEBCAST\n\nMORE ACM AWARDS\n\nHOME\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA.M. TURING AWARD LAUREATES BY...\n\nALPHABETICAL LISTING\n\nYEAR OF THE AWARD\n\nRESEARCH SUBJECT\n\nPHOTOGRAPHS\n\nBIRTH:\n\nJuly 27, 1945.\n\nDEATH:\n\nDecember 22, 2020.\n\nEDUCATION:\n\nBA, Mathematics, (University of Virginia, 1967); MA Mathematics (Duke University, 1968);Ph.D., Computer Science (Cornell University, 1976)\n\nEXPERIENCE:",
                "4": "Inventing model checking"
            },
            "qa_cat": "What did Amir Pnueli introduce in 1977?\nIn 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems that allows explicit reasoning about time."
        },
        {
            "question": "What is the significance of introducing temporal logic in system verification?",
            "answer": "Temporal logic allowed researchers to express statements such as 'This condition will remain true until a second condition becomes true', making it possible to verify that systems perform according to specification every time, no matter the circumstances.",
            "top_k_docs": {
                "0": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "1": "Early researchers addressed this mismatch by developing logical forms better-suited to describing computer systems. One of the first was by Tony Hoare . Hoare\u2019s logic could be used to prove that every possible execution of a system would only execute an acceptable sequence of operations. This opened the possibility that systems could be proven to perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and",
                "2": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "3": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "4": "Conference on Automated Deduction (CADE) Herbrand Award for Distinguished Contributions to Automated Reasoning (2008); Logic in Computing Science (LICS) 2010 Test-of-Time Award for his 1990 paper, \"Symbolic model checking\u2026; Elected to the American Academy of Arts and Sciences (2011); Fellow of the ACM and IEEE; Honorary Doctorate, (Vienna University of Technology, 2012); Bower Award and Prize for Achievement in Science from the Franklin Institute (2014) ."
            },
            "qa_cat": "What is the significance of introducing temporal logic in system verification?\nTemporal logic allowed researchers to express statements such as 'This condition will remain true until a second condition becomes true', making it possible to verify that systems perform according to specification every time, no matter the circumstances."
        },
        {
            "question": "What was the dream of early researchers in system verification?",
            "answer": "The dream of early researchers was to develop powerful and effective methods for reasoning about all possible orderings of a system, which remained unfulfilled despite advancements like Hoare's logic and temporal logic.",
            "top_k_docs": {
                "0": "Early researchers addressed this mismatch by developing logical forms better-suited to describing computer systems. One of the first was by Tony Hoare . Hoare\u2019s logic could be used to prove that every possible execution of a system would only execute an acceptable sequence of operations. This opened the possibility that systems could be proven to perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and",
                "1": "In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified property. Working independently, Jean-Pierre Queille and Joseph Sifakis developed similar ideas. The technology of model checking was born.",
                "2": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "3": "in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of integrated circuits, which feature multiple processors running simultaneously. Model checking has substantially improved the reliability and safety of the systems upon which modern life depends.",
                "4": "making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard University in 1978. He joined Carnegie Mellon University in 1982, where he is currently the FORE Systems University Professor of Computer Science and Professor of Electrical and Computer Engineering."
            },
            "qa_cat": "What was the dream of early researchers in system verification?\nThe dream of early researchers was to develop powerful and effective methods for reasoning about all possible orderings of a system, which remained unfulfilled despite advancements like Hoare's logic and temporal logic."
        },
        {
            "question": "What does the term 'multiple programs running simultaneously' mean in computer systems?",
            "answer": "The term 'multiple programs running simultaneously' refers to a feature of modern computer hardware where multiple software applications or processes can run at the same time, which presents challenges for system verification.",
            "top_k_docs": {
                "0": "The sequences become even more difficult to envision in systems with multiple programs running at the same time\u2014a feature that has long been present in computer hardware and has become widespread in software since the beginning of the 21st century. Mathematical reasoning, and specifically its expression in formal logic, in principle is sufficient to describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical",
                "1": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.",
                "2": "Systems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.",
                "3": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "4": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked."
            },
            "qa_cat": "What does the term 'multiple programs running simultaneously' mean in computer systems?\nThe term 'multiple programs running simultaneously' refers to a feature of modern computer hardware where multiple software applications or processes can run at the same time, which presents challenges for system verification."
        },
        {
            "question": "What is formal logic in mathematical reasoning?",
            "answer": "Formal logic is a branch of mathematics that studies logical reasoning and its expression in systems. It was initially thought to be sufficient to describe every possible sequence and ensure correctness, even for simultaneously-running programs.",
            "top_k_docs": {
                "0": "The sequences become even more difficult to envision in systems with multiple programs running at the same time\u2014a feature that has long been present in computer hardware and has become widespread in software since the beginning of the 21st century. Mathematical reasoning, and specifically its expression in formal logic, in principle is sufficient to describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical",
                "1": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "2": "In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified property. Working independently, Jean-Pierre Queille and Joseph Sifakis developed similar ideas. The technology of model checking was born.",
                "3": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard",
                "4": "Conference on Automated Deduction (CADE) Herbrand Award for Distinguished Contributions to Automated Reasoning (2008); Logic in Computing Science (LICS) 2010 Test-of-Time Award for his 1990 paper, \"Symbolic model checking\u2026; Elected to the American Academy of Arts and Sciences (2011); Fellow of the ACM and IEEE; Honorary Doctorate, (Vienna University of Technology, 2012); Bower Award and Prize for Achievement in Science from the Franklin Institute (2014) ."
            },
            "qa_cat": "What is formal logic in mathematical reasoning?\nFormal logic is a branch of mathematics that studies logical reasoning and its expression in systems. It was initially thought to be sufficient to describe every possible sequence and ensure correctness, even for simultaneously-running programs."
        },
        {
            "question": "Who introduced temporal logic?",
            "answer": "Amir Pnueli",
            "top_k_docs": {
                "0": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "1": "Clarke and his student E. Allen Emerson saw an important possibility in temporal logic: it could be directly checked by machine. Whereas Hoare\u2019s logic required the designer to consider every detail of both the system and the argument about the system\u2019s correctness\u2014substantially increasing the designer\u2019s workload\u2014Pnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the",
                "2": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard",
                "3": "Inventing model checking",
                "4": "Conference on Automated Deduction (CADE) Herbrand Award for Distinguished Contributions to Automated Reasoning (2008); Logic in Computing Science (LICS) 2010 Test-of-Time Award for his 1990 paper, \"Symbolic model checking\u2026; Elected to the American Academy of Arts and Sciences (2011); Fellow of the ACM and IEEE; Honorary Doctorate, (Vienna University of Technology, 2012); Bower Award and Prize for Achievement in Science from the Franklin Institute (2014) ."
            },
            "qa_cat": "Who introduced temporal logic?\nAmir Pnueli"
        },
        {
            "question": "What is unique about temporal logic compared to Hoare's logic?",
            "answer": "Temporal logic can be directly checked by machine, whereas Hoare\u2019s logic requires the designer to consider every detail of both the system and the argument about the system\u2019s correctness.",
            "top_k_docs": {
                "0": "Clarke and his student E. Allen Emerson saw an important possibility in temporal logic: it could be directly checked by machine. Whereas Hoare\u2019s logic required the designer to consider every detail of both the system and the argument about the system\u2019s correctness\u2014substantially increasing the designer\u2019s workload\u2014Pnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the",
                "1": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "2": "Early researchers addressed this mismatch by developing logical forms better-suited to describing computer systems. One of the first was by Tony Hoare . Hoare\u2019s logic could be used to prove that every possible execution of a system would only execute an acceptable sequence of operations. This opened the possibility that systems could be proven to perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and",
                "3": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "4": "With enhancements such as these, model checking has become a mature technology. It is widely used to verify designs for integrated circuits, computer networks, and software, by companies such as Intel and Microsoft. Model checkers have been used to analyze systems whose state space (10 120) is substantially larger than the number of atoms in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of"
            },
            "qa_cat": "What is unique about temporal logic compared to Hoare's logic?\nTemporal logic can be directly checked by machine, whereas Hoare\u2019s logic requires the designer to consider every detail of both the system and the argument about the system\u2019s correctness."
        },
        {
            "question": "What did Clarke and Emerson realize about temporal logic?",
            "answer": "They realized that a program could exhaustively construct every possible sequence of actions a system might perform, and for every action it could evaluate a property expressed in temporal logic. If the program found the property to be true for every possible action in every possible sequence, this proved the property for the system.",
            "top_k_docs": {
                "0": "Clarke and Emerson realized that a program could exhaustively construct every possible sequence of actions a system might perform, and for every action it could evaluate a property expressed in temporal logic. If the program found the property to be true for every possible action in every possible sequence, this proved the property for the system. In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified",
                "1": "Clarke and his student E. Allen Emerson saw an important possibility in temporal logic: it could be directly checked by machine. Whereas Hoare\u2019s logic required the designer to consider every detail of both the system and the argument about the system\u2019s correctness\u2014substantially increasing the designer\u2019s workload\u2014Pnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the",
                "2": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "3": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "4": "The sequences become even more difficult to envision in systems with multiple programs running at the same time\u2014a feature that has long been present in computer hardware and has become widespread in software since the beginning of the 21st century. Mathematical reasoning, and specifically its expression in formal logic, in principle is sufficient to describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical"
            },
            "qa_cat": "What did Clarke and Emerson realize about temporal logic?\nThey realized that a program could exhaustively construct every possible sequence of actions a system might perform, and for every action it could evaluate a property expressed in temporal logic. If the program found the property to be true for every possible action in every possible sequence, this proved the property for the system."
        },
        {
            "question": "Who else developed similar ideas about model checking?",
            "answer": "Jean-Pierre Queille and Joseph Sifakis",
            "top_k_docs": {
                "0": "In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified property. Working independently, Jean-Pierre Queille and Joseph Sifakis developed similar ideas. The technology of model checking was born.",
                "1": "Inventing model checking",
                "2": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "3": "describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical mathematical reasoning is awkwardly-matched to describing the many possible execution orderings in a computer system.",
                "4": "Conference on Automated Deduction (CADE) Herbrand Award for Distinguished Contributions to Automated Reasoning (2008); Logic in Computing Science (LICS) 2010 Test-of-Time Award for his 1990 paper, \"Symbolic model checking\u2026; Elected to the American Academy of Arts and Sciences (2011); Fellow of the ACM and IEEE; Honorary Doctorate, (Vienna University of Technology, 2012); Bower Award and Prize for Achievement in Science from the Franklin Institute (2014) ."
            },
            "qa_cat": "Who else developed similar ideas about model checking?\nJean-Pierre Queille and Joseph Sifakis"
        },
        {
            "question": "What is a great strength of the model checking approach?",
            "answer": "When it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong.",
            "top_k_docs": {
                "0": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "1": "Clarke and Emerson realized that a program could exhaustively construct every possible sequence of actions a system might perform, and for every action it could evaluate a property expressed in temporal logic. If the program found the property to be true for every possible action in every possible sequence, this proved the property for the system. In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified",
                "2": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "3": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.",
                "4": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked."
            },
            "qa_cat": "What is a great strength of the model checking approach?\nWhen it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong."
        },
        {
            "question": "What is the value of model checking for designers?",
            "answer": "The error traces provided by model checking are invaluable for designers, because they precisely locate the source of the problems.",
            "top_k_docs": {
                "0": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "1": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "2": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education",
                "3": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.",
                "4": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked."
            },
            "qa_cat": "What is the value of model checking for designers?\nThe error traces provided by model checking are invaluable for designers, because they precisely locate the source of the problems."
        },
        {
            "question": "Why was Pnueli's logic beneficial to computer system verification?",
            "answer": "Pnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.",
            "top_k_docs": {
                "0": "Clarke and his student E. Allen Emerson saw an important possibility in temporal logic: it could be directly checked by machine. Whereas Hoare\u2019s logic required the designer to consider every detail of both the system and the argument about the system\u2019s correctness\u2014substantially increasing the designer\u2019s workload\u2014Pnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the",
                "1": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "2": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.",
                "3": "With enhancements such as these, model checking has become a mature technology. It is widely used to verify designs for integrated circuits, computer networks, and software, by companies such as Intel and Microsoft. Model checkers have been used to analyze systems whose state space (10 120) is substantially larger than the number of atoms in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of",
                "4": "describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical mathematical reasoning is awkwardly-matched to describing the many possible execution orderings in a computer system."
            },
            "qa_cat": "Why was Pnueli's logic beneficial to computer system verification?\nPnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly."
        },
        {
            "question": "What is temporal logic used for?",
            "answer": "Temporal logic allows explicit reasoning about time. It is possible to express statements such as, 'This condition will remain true until a second condition becomes true' in it.",
            "top_k_docs": {
                "0": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "1": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "2": "Clarke and Emerson realized that a program could exhaustively construct every possible sequence of actions a system might perform, and for every action it could evaluate a property expressed in temporal logic. If the program found the property to be true for every possible action in every possible sequence, this proved the property for the system. In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified",
                "3": "With enhancements such as these, model checking has become a mature technology. It is widely used to verify designs for integrated circuits, computer networks, and software, by companies such as Intel and Microsoft. Model checkers have been used to analyze systems whose state space (10 120) is substantially larger than the number of atoms in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of",
                "4": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life."
            },
            "qa_cat": "What is temporal logic used for?\nTemporal logic allows explicit reasoning about time. It is possible to express statements such as, 'This condition will remain true until a second condition becomes true' in it."
        },
        {
            "question": "What is one of the strengths of the model checking approach?",
            "answer": "One of the great strengths of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem.",
            "top_k_docs": {
                "0": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "1": "In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified property. Working independently, Jean-Pierre Queille and Joseph Sifakis developed similar ideas. The technology of model checking was born.",
                "2": "Inventing model checking",
                "3": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "4": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d."
            },
            "qa_cat": "What is one of the strengths of the model checking approach?\nOne of the great strengths of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem."
        },
        {
            "question": "Why were early model checkers not ready for wider use?",
            "answer": "Early model checkers required explicitly computing every possible configuration of values a program might assume, which led to an explosive growth in the number of states. This rapid growth is called the state space explosion.",
            "top_k_docs": {
                "0": "Systems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.",
                "1": "Although the 1981 paper [ 2 ] demonstrated that the model checking was possible in principle, its application to practical systems was severely limited. The most pressing limitation was the number of states to search. Early model checkers required explicitly computing every possible configuration of values the program might assume. For example, if a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be",
                "2": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "3": "In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified property. Working independently, Jean-Pierre Queille and Joseph Sifakis developed similar ideas. The technology of model checking was born.",
                "4": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life."
            },
            "qa_cat": "Why were early model checkers not ready for wider use?\nEarly model checkers required explicitly computing every possible configuration of values a program might assume, which led to an explosive growth in the number of states. This rapid growth is called the state space explosion."
        },
        {
            "question": "What was demonstrated by the 1981 paper [2]?",
            "answer": "The 1981 paper [2] demonstrated that model checking was possible in principle, but its application to practical systems was severely limited due to the number of states to search.",
            "top_k_docs": {
                "0": "Although the 1981 paper [ 2 ] demonstrated that the model checking was possible in principle, its application to practical systems was severely limited. The most pressing limitation was the number of states to search. Early model checkers required explicitly computing every possible configuration of values the program might assume. For example, if a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be",
                "1": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "2": "perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and extended his method. Although Hoare\u2019s method worked for smaller systems, it was close to impossible to apply to systems of any real size. The dream of powerful, effective methods for reasoning about all possible orderings of a system remained unfulfilled.",
                "3": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "4": "making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard University in 1978. He joined Carnegie Mellon University in 1982, where he is currently the FORE Systems University Professor of Computer Science and Professor of Electrical and Computer Engineering."
            },
            "qa_cat": "What was demonstrated by the 1981 paper [2]?\nThe 1981 paper [2] demonstrated that model checking was possible in principle, but its application to practical systems was severely limited due to the number of states to search."
        },
        {
            "question": "What is one limitation of early model checkers?",
            "answer": "One limitation of early model checkers was their ability to handle large amounts of data. The number of possible states grows at an explosive speed, which made it difficult for them to verify that a required property was true for every state.",
            "top_k_docs": {
                "0": "Although the 1981 paper [ 2 ] demonstrated that the model checking was possible in principle, its application to practical systems was severely limited. The most pressing limitation was the number of states to search. Early model checkers required explicitly computing every possible configuration of values the program might assume. For example, if a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be",
                "1": "Systems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.",
                "2": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "3": "Clarke and Emerson realized that a program could exhaustively construct every possible sequence of actions a system might perform, and for every action it could evaluate a property expressed in temporal logic. If the program found the property to be true for every possible action in every possible sequence, this proved the property for the system. In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified",
                "4": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life."
            },
            "qa_cat": "What is one limitation of early model checkers?\nOne limitation of early model checkers was their ability to handle large amounts of data. The number of possible states grows at an explosive speed, which made it difficult for them to verify that a required property was true for every state."
        },
        {
            "question": "What is the state space explosion?",
            "answer": "The state space explosion refers to the rapid growth in the number of possible states as more data is manipulated. This makes it difficult for model checkers to verify that a required property is true for every state.",
            "top_k_docs": {
                "0": "Systems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.",
                "1": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "2": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "3": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "4": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states."
            },
            "qa_cat": "What is the state space explosion?\nThe state space explosion refers to the rapid growth in the number of possible states as more data is manipulated. This makes it difficult for model checkers to verify that a required property is true for every state."
        },
        {
            "question": "How does the error traces provided by model checking help designers?",
            "answer": "The error traces provided by model checking are invaluable for designers because they precisely locate the source of problems. This helps them understand where their designs went wrong and how to fix these issues.",
            "top_k_docs": {
                "0": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "1": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "2": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education",
                "3": "perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and extended his method. Although Hoare\u2019s method worked for smaller systems, it was close to impossible to apply to systems of any real size. The dream of powerful, effective methods for reasoning about all possible orderings of a system remained unfulfilled.",
                "4": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states."
            },
            "qa_cat": "How does the error traces provided by model checking help designers?\nThe error traces provided by model checking are invaluable for designers because they precisely locate the source of problems. This helps them understand where their designs went wrong and how to fix these issues."
        },
        {
            "question": "What is one example given in the text that requires 7 storage locations?",
            "answer": "One example given in the text that requires 7 storage locations is a program that counts the millimeters of rain at a weather station each day of the week. Each location needs to be big enough to hold the largest rain level expected in a single day.",
            "top_k_docs": {
                "0": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "1": "Although the 1981 paper [ 2 ] demonstrated that the model checking was possible in principle, its application to practical systems was severely limited. The most pressing limitation was the number of states to search. Early model checkers required explicitly computing every possible configuration of values the program might assume. For example, if a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be",
                "2": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "3": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "4": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked."
            },
            "qa_cat": "What is one example given in the text that requires 7 storage locations?\nOne example given in the text that requires 7 storage locations is a program that counts the millimeters of rain at a weather station each day of the week. Each location needs to be big enough to hold the largest rain level expected in a single day."
        },
        {
            "question": "How many possible states does this simple program have?",
            "answer": "This simple program has 10^21 possible states, which is slightly less than the number of stars in the observable universe. This is due to the fact that it needs to store each day's rain level for every day of the week.",
            "top_k_docs": {
                "0": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "1": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "2": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "3": "Clarke and Emerson realized that a program could exhaustively construct every possible sequence of actions a system might perform, and for every action it could evaluate a property expressed in temporal logic. If the program found the property to be true for every possible action in every possible sequence, this proved the property for the system. In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified",
                "4": "With enhancements such as these, model checking has become a mature technology. It is widely used to verify designs for integrated circuits, computer networks, and software, by companies such as Intel and Microsoft. Model checkers have been used to analyze systems whose state space (10 120) is substantially larger than the number of atoms in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of"
            },
            "qa_cat": "How many possible states does this simple program have?\nThis simple program has 10^21 possible states, which is slightly less than the number of stars in the observable universe. This is due to the fact that it needs to store each day's rain level for every day of the week."
        },
        {
            "question": "What does 'practical systems' refer to?",
            "answer": "In this context, 'practical systems' refers to computer programs or designs that are large enough to handle significant amounts of data and complex operations. These systems require more advanced model checking techniques than those used for small systems.",
            "top_k_docs": {
                "0": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.",
                "1": "Systems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.",
                "2": "Early researchers addressed this mismatch by developing logical forms better-suited to describing computer systems. One of the first was by Tony Hoare . Hoare\u2019s logic could be used to prove that every possible execution of a system would only execute an acceptable sequence of operations. This opened the possibility that systems could be proven to perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and",
                "3": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "4": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states."
            },
            "qa_cat": "What does 'practical systems' refer to?\nIn this context, 'practical systems' refers to computer programs or designs that are large enough to handle significant amounts of data and complex operations. These systems require more advanced model checking techniques than those used for small systems."
        },
        {
            "question": "What is the state space explosion?",
            "answer": "The rapid growth in the number of possible states as systems become more complex.",
            "top_k_docs": {
                "0": "Systems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.",
                "1": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "2": "describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical mathematical reasoning is awkwardly-matched to describing the many possible execution orderings in a computer system.",
                "3": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "4": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d."
            },
            "qa_cat": "What is the state space explosion?\nThe rapid growth in the number of possible states as systems become more complex."
        },
        {
            "question": "Why was early model checker technology not ready for wider use?",
            "answer": "Because it could only handle small systems due to the state space explosion.",
            "top_k_docs": {
                "0": "Systems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.",
                "1": "Although the 1981 paper [ 2 ] demonstrated that the model checking was possible in principle, its application to practical systems was severely limited. The most pressing limitation was the number of states to search. Early model checkers required explicitly computing every possible configuration of values the program might assume. For example, if a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be",
                "2": "The new representation dramatically reduced the storage required to represent state spaces, in turn reducing the time required to run a model checker on systems of practical size. They called these new systems symbolic model checkers. In 1995, Clarke, McMillan, and colleagues used this approach to demonstrate flaws in the design of an IEEE standard for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases",
                "3": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "4": "perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and extended his method. Although Hoare\u2019s method worked for smaller systems, it was close to impossible to apply to systems of any real size. The dream of powerful, effective methods for reasoning about all possible orderings of a system remained unfulfilled."
            },
            "qa_cat": "Why was early model checker technology not ready for wider use?\nBecause it could only handle small systems due to the state space explosion."
        },
        {
            "question": "What did Clarke and McMillan observe about memory locations in practical-sized systems?",
            "answer": "They observed that a single memory location can represent many potential states, but only one at a time.",
            "top_k_docs": {
                "0": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "1": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "2": "Clarke\u2019s career has focused on mathematical reasoning about computer systems, with an emphasis on reasoning about the reliability of those systems. Such reasoning is necessary but very hard. A computer system executes simple operations, but those operations can occur in a staggering number of different orders. This makes it impossible for the designer to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be",
                "3": "Although the 1981 paper [ 2 ] demonstrated that the model checking was possible in principle, its application to practical systems was severely limited. The most pressing limitation was the number of states to search. Early model checkers required explicitly computing every possible configuration of values the program might assume. For example, if a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be",
                "4": "making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard University in 1978. He joined Carnegie Mellon University in 1982, where he is currently the FORE Systems University Professor of Computer Science and Professor of Electrical and Computer Engineering."
            },
            "qa_cat": "What did Clarke and McMillan observe about memory locations in practical-sized systems?\nThey observed that a single memory location can represent many potential states, but only one at a time."
        },
        {
            "question": "How did the new representation by Clarke and McMillan reduce storage requirements for state spaces?",
            "answer": "It dramatically reduced storage required to represent state spaces by tersely encoding multiple states while permitting efficient computation of formulas in temporal logic.",
            "top_k_docs": {
                "0": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "1": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "2": "The new representation dramatically reduced the storage required to represent state spaces, in turn reducing the time required to run a model checker on systems of practical size. They called these new systems symbolic model checkers. In 1995, Clarke, McMillan, and colleagues used this approach to demonstrate flaws in the design of an IEEE standard for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases",
                "3": "Clarke and his student E. Allen Emerson saw an important possibility in temporal logic: it could be directly checked by machine. Whereas Hoare\u2019s logic required the designer to consider every detail of both the system and the argument about the system\u2019s correctness\u2014substantially increasing the designer\u2019s workload\u2014Pnueli\u2019s logic could be implemented in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the",
                "4": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard"
            },
            "qa_cat": "How did the new representation by Clarke and McMillan reduce storage requirements for state spaces?\nIt dramatically reduced storage required to represent state spaces by tersely encoding multiple states while permitting efficient computation of formulas in temporal logic."
        },
        {
            "question": "What did Clarke, McMillan, and colleagues demonstrate using symbolic model checkers?",
            "answer": "They demonstrated flaws in the design of an IEEE standard for interconnecting computer components by exhaustively checking every possible case.",
            "top_k_docs": {
                "0": "The new representation dramatically reduced the storage required to represent state spaces, in turn reducing the time required to run a model checker on systems of practical size. They called these new systems symbolic model checkers. In 1995, Clarke, McMillan, and colleagues used this approach to demonstrate flaws in the design of an IEEE standard for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases",
                "1": "Clarke and Emerson realized that a program could exhaustively construct every possible sequence of actions a system might perform, and for every action it could evaluate a property expressed in temporal logic. If the program found the property to be true for every possible action in every possible sequence, this proved the property for the system. In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified",
                "2": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education",
                "3": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked.",
                "4": "Inventing model checking"
            },
            "qa_cat": "What did Clarke, McMillan, and colleagues demonstrate using symbolic model checkers?\nThey demonstrated flaws in the design of an IEEE standard for interconnecting computer components by exhaustively checking every possible case."
        },
        {
            "question": "Why was it important to thoroughly analyze the reliability of the IEEE standard using symbolic model checkers?",
            "answer": "It allowed for the discovery and consideration of potential errors in rare cases that had been previously overlooked.",
            "top_k_docs": {
                "0": "The new representation dramatically reduced the storage required to represent state spaces, in turn reducing the time required to run a model checker on systems of practical size. They called these new systems symbolic model checkers. In 1995, Clarke, McMillan, and colleagues used this approach to demonstrate flaws in the design of an IEEE standard for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases",
                "1": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked.",
                "2": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "3": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "4": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states."
            },
            "qa_cat": "Why was it important to thoroughly analyze the reliability of the IEEE standard using symbolic model checkers?\nIt allowed for the discovery and consideration of potential errors in rare cases that had been previously overlooked."
        },
        {
            "question": "What is a symbolic model checker?",
            "answer": "A type of system that uses an encoding to represent many potential states with a single value, allowing for efficient computation and reduced storage requirements.",
            "top_k_docs": {
                "0": "The new representation dramatically reduced the storage required to represent state spaces, in turn reducing the time required to run a model checker on systems of practical size. They called these new systems symbolic model checkers. In 1995, Clarke, McMillan, and colleagues used this approach to demonstrate flaws in the design of an IEEE standard for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases",
                "1": "With enhancements such as these, model checking has become a mature technology. It is widely used to verify designs for integrated circuits, computer networks, and software, by companies such as Intel and Microsoft. Model checkers have been used to analyze systems whose state space (10 120) is substantially larger than the number of atoms in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of",
                "2": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "3": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "4": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life."
            },
            "qa_cat": "What is a symbolic model checker?\nA type of system that uses an encoding to represent many potential states with a single value, allowing for efficient computation and reduced storage requirements."
        },
        {
            "question": "How did the new representation by Clarke and McMillan improve upon early model checkers?",
            "answer": "It allowed for the representation of much larger systems without an exponential increase in memory usage or computational time, making it feasible for practical-sized systems.",
            "top_k_docs": {
                "0": "The new representation dramatically reduced the storage required to represent state spaces, in turn reducing the time required to run a model checker on systems of practical size. They called these new systems symbolic model checkers. In 1995, Clarke, McMillan, and colleagues used this approach to demonstrate flaws in the design of an IEEE standard for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases",
                "1": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "2": "Clarke and Emerson realized that a program could exhaustively construct every possible sequence of actions a system might perform, and for every action it could evaluate a property expressed in temporal logic. If the program found the property to be true for every possible action in every possible sequence, this proved the property for the system. In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified",
                "3": "Inventing model checking",
                "4": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states."
            },
            "qa_cat": "How did the new representation by Clarke and McMillan improve upon early model checkers?\nIt allowed for the representation of much larger systems without an exponential increase in memory usage or computational time, making it feasible for practical-sized systems."
        },
        {
            "question": "What is state space explosion and how does it affect model checkers?",
            "answer": "State space explosion refers to the rapid growth of possible states as a system becomes more complex. This makes it difficult for early model checkers, which were designed for small systems, to handle larger ones efficiently.",
            "top_k_docs": {
                "0": "Systems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.",
                "1": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "2": "Clarke and his student Ken McMillan had a fundamental insight: The state space explodes because the number of states a memory location can assume is much, much bigger than the size of the location itself. The memory location is compact because it encodes many potential states but only contains one at a time. Clarke and McMillan observed that this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature,",
                "3": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "4": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education"
            },
            "qa_cat": "What is state space explosion and how does it affect model checkers?\nState space explosion refers to the rapid growth of possible states as a system becomes more complex. This makes it difficult for early model checkers, which were designed for small systems, to handle larger ones efficiently."
        },
        {
            "question": "What is model checking used to verify?",
            "answer": "Model checking is used to verify designs for integrated circuits, computer networks, and software.",
            "top_k_docs": {
                "0": "With enhancements such as these, model checking has become a mature technology. It is widely used to verify designs for integrated circuits, computer networks, and software, by companies such as Intel and Microsoft. Model checkers have been used to analyze systems whose state space (10 120) is substantially larger than the number of atoms in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of",
                "1": "Inventing model checking",
                "2": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education",
                "3": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "4": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life."
            },
            "qa_cat": "What is model checking used to verify?\nModel checking is used to verify designs for integrated circuits, computer networks, and software."
        },
        {
            "question": "How has the use of model checkers improved systems in recent years?",
            "answer": "The use of model checkers has substantially improved the reliability and safety of the systems upon which modern life depends.",
            "top_k_docs": {
                "0": "in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of integrated circuits, which feature multiple processors running simultaneously. Model checking has substantially improved the reliability and safety of the systems upon which modern life depends.",
                "1": "A great strength of the model checking approach is that when it detects a problem in a system design, the checker prints out an example sequence of actions that gives rise to the problem. Initial designs always get some details wrong. The error traces provided by model checking are invaluable for designers, because the traces precisely locate the source of the problems.\n\nAverting the state space explosion",
                "2": "The new representation dramatically reduced the storage required to represent state spaces, in turn reducing the time required to run a model checker on systems of practical size. They called these new systems symbolic model checkers. In 1995, Clarke, McMillan, and colleagues used this approach to demonstrate flaws in the design of an IEEE standard for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases",
                "3": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "4": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states."
            },
            "qa_cat": "How has the use of model checkers improved systems in recent years?\nThe use of model checkers has substantially improved the reliability and safety of the systems upon which modern life depends."
        },
        {
            "question": "What is the state space that model checkers have been used to analyze?",
            "answer": "Model checkers have been used to analyze systems whose state space (10 120) is substantially larger than the number of atoms in the observable universe.",
            "top_k_docs": {
                "0": "With enhancements such as these, model checking has become a mature technology. It is widely used to verify designs for integrated circuits, computer networks, and software, by companies such as Intel and Microsoft. Model checkers have been used to analyze systems whose state space (10 120) is substantially larger than the number of atoms in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of",
                "1": "Systems of practical size manipulate much more data than the simple example above. The number of possible states grows as well, at an explosive speed. This rapid growth is called the state space explosion . Although early model checkers demonstrated that the technology was feasible for small systems, it was not ready for wider use.",
                "2": "Although the 1981 paper [ 2 ] demonstrated that the model checking was possible in principle, its application to practical systems was severely limited. The most pressing limitation was the number of states to search. Early model checkers required explicitly computing every possible configuration of values the program might assume. For example, if a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be",
                "3": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "4": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life."
            },
            "qa_cat": "What is the state space that model checkers have been used to analyze?\nModel checkers have been used to analyze systems whose state space (10 120) is substantially larger than the number of atoms in the observable universe."
        },
        {
            "question": "What has become particularly important for model checking recently?",
            "answer": "It is becoming particularly important in the verification of software designed for recent generations of integrated circuits, which feature multiple processors running simultaneously.",
            "top_k_docs": {
                "0": "in the observable universe (around 10 80 ). It is becoming particularly important in the verification of software designed for recent generations of integrated circuits, which feature multiple processors running simultaneously. Model checking has substantially improved the reliability and safety of the systems upon which modern life depends.",
                "1": "In the language of mathematical logic, Clarke and Emerson\u2019s program checked that the possible execution sequences form a \u201cmodel\u201d of the specified property. Working independently, Jean-Pierre Queille and Joseph Sifakis developed similar ideas. The technology of model checking was born.",
                "2": "The sequences become even more difficult to envision in systems with multiple programs running at the same time\u2014a feature that has long been present in computer hardware and has become widespread in software since the beginning of the 21st century. Mathematical reasoning, and specifically its expression in formal logic, in principle is sufficient to describe every possible sequence and ensure that all of them are correct, even for simultaneously-running programs. In practice, however, classical",
                "3": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education",
                "4": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d."
            },
            "qa_cat": "What has become particularly important for model checking recently?\nIt is becoming particularly important in the verification of software designed for recent generations of integrated circuits, which feature multiple processors running simultaneously."
        },
        {
            "question": "Who wrote this text?",
            "answer": "The author of this text is Ted Kirkpatrick",
            "top_k_docs": {
                "0": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard",
                "1": "Author: Ted Kirkpatrick\n\nABOUT THE A.M. TURING AWARD NOMINATIONS\n\nVIDEO: THE ORIGINS OF THE AWARD\n\n2021 LAUREATE: JACK DONGARRA\n\nTHE A.M. TURING AWARD LECTURES\n\nACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals, delivering a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society.\n\n\u00a9 2019 Association for Computing Machinery. All rights reserved.",
                "2": "EXPERIENCE:\n\nDuke University (1976\u20131978); Harvard University (1978\u20131982); Carnegie Mellon University (1982\u2013present, including FORE Systems Professor 1995\u2013present, University Professor 2008\u2013present).\n\nHONORS AND AWARDS:",
                "3": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic.",
                "4": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly."
            },
            "qa_cat": "Who wrote this text?\nThe author of this text is Ted Kirkpatrick"
        },
        {
            "question": "What organization is widely recognized as the premier organization for computing professionals?",
            "answer": "ACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals.",
            "top_k_docs": {
                "0": "Author: Ted Kirkpatrick\n\nABOUT THE A.M. TURING AWARD NOMINATIONS\n\nVIDEO: THE ORIGINS OF THE AWARD\n\n2021 LAUREATE: JACK DONGARRA\n\nTHE A.M. TURING AWARD LECTURES\n\nACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals, delivering a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society.\n\n\u00a9 2019 Association for Computing Machinery. All rights reserved.",
                "1": "EXPERIENCE:\n\nDuke University (1976\u20131978); Harvard University (1978\u20131982); Carnegie Mellon University (1982\u2013present, including FORE Systems Professor 1995\u2013present, University Professor 2008\u2013present).\n\nHONORS AND AWARDS:",
                "2": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked.",
                "3": "Conference on Automated Deduction (CADE) Herbrand Award for Distinguished Contributions to Automated Reasoning (2008); Logic in Computing Science (LICS) 2010 Test-of-Time Award for his 1990 paper, \"Symbolic model checking\u2026; Elected to the American Academy of Arts and Sciences (2011); Fellow of the ACM and IEEE; Honorary Doctorate, (Vienna University of Technology, 2012); Bower Award and Prize for Achievement in Science from the Franklin Institute (2014) .",
                "4": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly."
            },
            "qa_cat": "What organization is widely recognized as the premier organization for computing professionals?\nACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals."
        },
        {
            "question": "What does ACM deliver to advance the computing and IT disciplines?",
            "answer": "ACM delivers a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society.",
            "top_k_docs": {
                "0": "Author: Ted Kirkpatrick\n\nABOUT THE A.M. TURING AWARD NOMINATIONS\n\nVIDEO: THE ORIGINS OF THE AWARD\n\n2021 LAUREATE: JACK DONGARRA\n\nTHE A.M. TURING AWARD LECTURES\n\nACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals, delivering a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society.\n\n\u00a9 2019 Association for Computing Machinery. All rights reserved.",
                "1": "making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard University in 1978. He joined Carnegie Mellon University in 1982, where he is currently the FORE Systems University Professor of Computer Science and Professor of Electrical and Computer Engineering.",
                "2": "in a computer program. The responsibilities could be divided: the designer focused on specifying the system, while the software ensured that the proposed system would always perform correctly.",
                "3": "perform according to specification every time, no matter the circumstances. Clarke\u2019s early research strengthened the foundations of Hoare\u2019s logic and extended his method. Although Hoare\u2019s method worked for smaller systems, it was close to impossible to apply to systems of any real size. The dream of powerful, effective methods for reasoning about all possible orderings of a system remained unfulfilled.",
                "4": "for interconnecting computer components. Before this, the reliability of such standards had only been informally analyzed, leaving many rare cases unconsidered and potential errors undiscovered. This was the first time every possible case of an IEEE standard had been exhaustively checked."
            },
            "qa_cat": "What does ACM deliver to advance the computing and IT disciplines?\nACM delivers a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society."
        },
        {
            "question": "When was this text written?",
            "answer": "This text was written in 2019",
            "top_k_docs": {
                "0": "In 1977, Amir Pnueli introduced temporal logic, an alternative logic for verifying computer systems. As the name implies, temporal logic allows explicit reasoning about time. In temporal logic it is possible to express statements such as, \u201cThis condition will remain true until a second condition becomes true\u201d.",
                "1": "Edmund Melson Clarke was born on July 27, 1945. He initially studied mathematics, receiving a BA from the University of Virginia in 1967 and an MA from Duke University in 1968. But by the time he enrolled in a doctoral program at Cornell University, he had switched to computing science. At Cornell he studied under Robert Constable , a pioneer in making deep connections between mathematical logic and computing. After graduation Clarke returned to teach at Duke for two years, moving to Harvard",
                "2": "to envision every possible sequence and predict its consequences. Yet every one of those sequences, no matter how infrequently executed, must be correct. If a program executes an incorrect sequence, at the very least it will waste a user\u2019s time, while at the worst it could cause injury or loss of life.",
                "3": "a program counts the millimeters of rain at a weather station each day of the week, it will need 7 storage locations. Each location will have to be big enough to hold the largest rain level expected in a single day. If the highest rain level in a day is 1 meter, this simple program will have 10 21 possible states, slightly less than the number of stars in the observable universe. Early model checkers would have to verify that the required property was true for every one of those states.",
                "4": "EXPERIENCE:\n\nDuke University (1976\u20131978); Harvard University (1978\u20131982); Carnegie Mellon University (1982\u2013present, including FORE Systems Professor 1995\u2013present, University Professor 2008\u2013present).\n\nHONORS AND AWARDS:"
            },
            "qa_cat": "When was this text written?\nThis text was written in 2019"
        },
        {
            "question": "What is the name of the award mentioned in the last paragraph?",
            "answer": "The A.M. Turing Award is mentioned in the last paragraph.",
            "top_k_docs": {
                "0": "Author: Ted Kirkpatrick\n\nABOUT THE A.M. TURING AWARD NOMINATIONS\n\nVIDEO: THE ORIGINS OF THE AWARD\n\n2021 LAUREATE: JACK DONGARRA\n\nTHE A.M. TURING AWARD LECTURES\n\nACM ( www.acm.org ) is widely recognized as the premier organization for computing professionals, delivering a broad array of resources that advance the computing and IT disciplines, enable professional development, and promote policies and research that benefit society.\n\n\u00a9 2019 Association for Computing Machinery. All rights reserved.",
                "1": "A.M. TURING CENTENARY CELEBRATION WEBCAST\n\nMORE ACM AWARDS\n\nHOME\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA.M. TURING AWARD LAUREATES BY...\n\nALPHABETICAL LISTING\n\nYEAR OF THE AWARD\n\nRESEARCH SUBJECT\n\nPHOTOGRAPHS\n\nBIRTH:\n\nJuly 27, 1945.\n\nDEATH:\n\nDecember 22, 2020.\n\nEDUCATION:\n\nBA, Mathematics, (University of Virginia, 1967); MA Mathematics (Duke University, 1968);Ph.D., Computer Science (Cornell University, 1976)\n\nEXPERIENCE:",
                "2": "Edmund Melson Clarke\n\nUnited States \u2013 2007\n\nCITATION\n\nTogether with E. Allen Emerson and Joseph Sifakis, for their role in developing Model-Checking into a highly effective verification technology that is widely adopted in the hardware and software industries.\n\nShort Annotated Bibliography\n\nACM Turing Award Lecture Video\n\nResearch Subjects\n\nBirth and education",
                "3": "Conference on Automated Deduction (CADE) Herbrand Award for Distinguished Contributions to Automated Reasoning (2008); Logic in Computing Science (LICS) 2010 Test-of-Time Award for his 1990 paper, \"Symbolic model checking\u2026; Elected to the American Academy of Arts and Sciences (2011); Fellow of the ACM and IEEE; Honorary Doctorate, (Vienna University of Technology, 2012); Bower Award and Prize for Achievement in Science from the Franklin Institute (2014) .",
                "4": "this process could be applied in reverse: with the right encoding, many potential states could be represented by a single value. From the literature, McMillan found an encoding that met the twin goals of tersely encoding multiple states while at the same time permitting efficient computation of formulas in temporal logic."
            },
            "qa_cat": "What is the name of the award mentioned in the last paragraph?\nThe A.M. Turing Award is mentioned in the last paragraph."
        }
    ]
}